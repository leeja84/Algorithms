During a surge in demand, an electric company activated generators to meet the demand. Now that the demand has passed, at least half of the generators need to be shut down. All generators of a particular model are similar and can be controlled as a single unit. Find the minimum number of models required to deactivate at least half of the generators. If there are n generators, then the ceiling of n/2 generators must be deactivated (ceiling is obtained when a floating point value is rounded up to the next higher integer, example ceiling(3/2) = ceiling(1.5) = 2). Example: n = 14 model = [3, 4, 6, 11, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8]. There are 14 generators, and the ceiling of n/2 = 14/2 = 7. At least 7 generators must be deactivated. One of the optimal solutions is deactivating two types of generators, models 9 and 8. The number of models 9 and 8 is 4 + 6 = 10, which is ≥ 7. The answer is 2. Function Description Complete the function reduceCapacity in the editor below. The function must return an integer. reduceCapacity has the following parameter(s): model: an array of integers, the model numbers of each generator. Constraints 1 ≤ n ≤ 105 1 ≤ model[i] ≤ 106




Sample Input For Custom Testing 7 7 10 1 2 7 7 1 Sample Output 2 Explanation n = 7 models = [7, 10, 1, 2, 7, 7, 1]



class Result {

    /*
     * Complete the 'reduceCapacity' function below.
     *
     * The function is expected to return an INTEGER.
     * The function accepts INTEGER_ARRAY model as parameter.
     */

    public static int reduceCapacity(List<Integer> model) {
    // Write your code here

    }

}




Two strings are "almost equivalent" if they have the same length AND for each lowercase letter x, the number of occurrences of x in the two strings differs at the most by 3. Given n pairs of strings, s[i] and t[i] are the strings in the ith pair which are of equal length and consist of English lowercase letters. For each pair find if they are almost equivalent or not. Example: s[i] = aabaab and t[i] = bbabbc. Number of a's in s[i] = 4 and in t[i] = 1 (difference is 3). Number of b's in s[i] = 2 and in t[i] = 4 (difference is 2). Number of c's in s[i] = 0 and in t[i] = 1 (difference is 1). Since neither character frequency differs by more than 3, this pair is almost equivalent. Function Description Complete the function areAlmostEquivalent in the editor below. The function must return a string array that consists of strings, either 'YES' or 'NO' in answer to each test case. areAlmostEquivalent has the following parameters: s[s[0],...s[n-1]]: an array of n strings t[t[0],...t[n-1]]: an array of n strings Constraints 1 ≤ n ≤ 5 1 ≤ length of any string in the input ≤ 105


Sample Input For Custom Testing 1 aaa 1 aab Sample Output YES Explanation Only letters 'a' and 'b' are present in the two strings. The number of occurrences of 'a' differs by 1 and the number of occurrences of 'b' differs also by 1, so the answer is YES.



class Result {

    /*
     * Complete the 'areAlmostEquivalent' function below.
     *
     * The function is expected to return a STRING_ARRAY.
     * The function accepts following parameters:
     *  1. STRING_ARRAY s
     *  2. STRING_ARRAY t
     */

    public static List<String> areAlmostEquivalent(List<String> s, List<String> t) {
         

    }

}



A student decides to perform some operations on big words to compress them, so they become easy to remember. An operation consists of choosing a group of K consecutive equal characters and removing them. The student keeps performing this operation as long as it's possible. What would be the final word after the operation is performed? Your goal is to help the student find the final word that will remain. Consider, for example, the string word = abbcccb and K = 3. We can remove 'c', now word = abbb. Now we can remove 'b', so the final word will be a. It can be easily proven that the final word will be unique. Also, it is guaranteed that the final word consists of at least one character. Function Description Complete the function compressWord in the editor below. The function must return a string denoting the final word. compressWord has the following parameter(s): word: a string of lowercase English letters K: an integer Constraints 1 ≤ |word| ≤ 105 1 < K ≤ |word|

Sample Input For Custom Testing aba 2 Sample Output aba Explanation You cannot delete any characters.





int count = 0; char c = 0; char before = 0; for (int i = 0; i < password.length(); i++) { c = password.charAt(i); if (c >= 48 && c <= 57 && (before + 1 == c)) { count++; if (count >= 2) return true; } else { count = 0; } before = c; }


class Result {

    /*
     * Complete the 'compressWord' function below.
     *
     * The function is expected to return a STRING.
     * The function accepts following parameters:
     *  1. STRING word
     *  2. INTEGER K
     */

    public static String compressWord(String word, int K) {
    // Write your code here
    

}
